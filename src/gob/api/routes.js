/**
 * Generated by Copilot per prompt: GO-AIBOB (GBOB) — GentleOmegaAI
 * 
 * routes.js - Express API routes for GO-AIBOB
 * 
 * Endpoints:
 * - POST /api/gob/enqueue - Enqueue URLs for scraping
 * - GET /api/gob/list - List scraped sites with filters
 * - GET /api/gob/:id - Get site details
 * - POST /api/gob/requeue/:id - Rescrape a site
 * - POST /api/gob/buy-backlink - Create backlink order
 * - GET /api/gob/export - Export sites as CSV/JSON
 * - GET /api/gob/health - Health check
 * - GET /api/gob/stats - Get scraping statistics
 */

import express from 'express';
import { queue } from '../worker/worker.js';
import {
  listSites,
  getSiteById,
  getSiteByUrl,
  createOrder,
  exportSitesToCSV,
  healthCheck
} from '../db/postgres.js';
import { calculateBacklinkValue } from '../scoring/score.js';
// import { isAdmin } from '../../../utils/admin-check.ts'; // TODO: Fix TypeScript import
import pino from 'pino';

const router = express.Router();
const logger = pino({
  level: process.env.LOG_LEVEL || 'info',
  transport: {
    target: 'pino-pretty',
    options: { colorize: true }
  }
});

/**
 * POST /api/gob/enqueue
 * Enqueue one or more URLs for scraping
 * 
 * Body: { urls: string[] } or { url: string }
 * Response: { jobIds: string[], queued: number }
 */
router.post('/enqueue', async (req, res) => {
  try {
    const { url, urls } = req.body;
    
    if (!url && (!urls || urls.length === 0)) {
      return res.status(400).json({
        error: 'Missing required field: url or urls'
      });
    }

    const urlList = urls || [url];
    
    // Validate URLs
    const validUrls = [];
    const invalidUrls = [];
    
    urlList.forEach(u => {
      try {
        new URL(u);
        validUrls.push(u);
      } catch (err) {
        invalidUrls.push({ url: u, error: 'Invalid URL format' });
      }
    });

    if (validUrls.length === 0) {
      return res.status(400).json({
        error: 'No valid URLs provided',
        invalid: invalidUrls
      });
    }

    // Enqueue jobs
    const jobs = await Promise.all(
      validUrls.map(url => 
        queue.add({
          url,
          metadata: {
            source: req.body.source || 'api',
            enqueuedAt: new Date().toISOString()
          }
        })
      )
    );

    logger.info(`✅ Enqueued ${jobs.length} URLs for scraping`);

    res.json({
      success: true,
      queued: jobs.length,
      jobIds: jobs.map(j => j.id),
      invalid: invalidUrls.length > 0 ? invalidUrls : undefined
    });

  } catch (err) {
    logger.error('Enqueue error:', err);
    res.status(500).json({
      error: 'Failed to enqueue URLs',
      message: err.message
    });
  }
});

/**
 * GET /api/gob/list
 * List scraped sites with filters and pagination
 * 
 * Query params:
 * - page: number (default 1)
 * - limit: number (default 20, max 100)
 * - status: string (new|scraped|enriched|error)
 * - category: string
 * - hasEmail: boolean
 * - minBacklinkValue: number
 * - maxSpamScore: number
 * - guestPostOnly: boolean
 */
router.get('/list', async (req, res) => {
  try {
    const page = parseInt(req.query.page) || 1;
    const limit = Math.min(parseInt(req.query.limit) || 20, 100);

    const filters = {
      status: req.query.status,
      category: req.query.category,
      hasEmail: req.query.hasEmail === 'true',
      minBacklinkValue: req.query.minBacklinkValue ? parseFloat(req.query.minBacklinkValue) : undefined,
      maxSpamScore: req.query.maxSpamScore ? parseInt(req.query.maxSpamScore) : undefined,
      guestPostOnly: req.query.guestPostOnly === 'true'
    };

    // Remove undefined filters
    Object.keys(filters).forEach(key => 
      filters[key] === undefined && delete filters[key]
    );

    const result = await listSites(filters, page, limit);

    res.json({
      success: true,
      ...result
    });

  } catch (err) {
    logger.error('List error:', err);
    res.status(500).json({
      error: 'Failed to list sites',
      message: err.message
    });
  }
});

/**
 * GET /api/gob/:id
 * Get detailed information about a scraped site
 */
router.get('/:id', async (req, res) => {
  try {
    const siteId = parseInt(req.params.id);
    
    if (isNaN(siteId)) {
      return res.status(400).json({
        error: 'Invalid site ID'
      });
    }

    const site = await getSiteById(siteId);

    if (!site) {
      return res.status(404).json({
        error: 'Site not found'
      });
    }

    res.json({
      success: true,
      site
    });

  } catch (err) {
    logger.error('Get site error:', err);
    res.status(500).json({
      error: 'Failed to get site',
      message: err.message
    });
  }
});

/**
 * POST /api/gob/requeue/:id
 * Re-scrape an existing site
 */
router.post('/requeue/:id', async (req, res) => {
  try {
    const siteId = parseInt(req.params.id);
    
    const site = await getSiteById(siteId);
    
    if (!site) {
      return res.status(404).json({
        error: 'Site not found'
      });
    }

    // Add to queue
    const job = await queue.add({
      url: site.url,
      metadata: {
        source: 'requeue',
        originalSiteId: siteId,
        requeuedAt: new Date().toISOString()
      }
    });

    logger.info(`✅ Requeued site ${siteId}: ${site.url}`);

    res.json({
      success: true,
      jobId: job.id,
      url: site.url
    });

  } catch (err) {
    logger.error('Requeue error:', err);
    res.status(500).json({
      error: 'Failed to requeue site',
      message: err.message
    });
  }
});

/**
 * POST /api/gob/buy-backlink
 * Create a backlink purchase order
 * 
 * Body: {
 *   site_id: number,
 *   buyer_name: string,
 *   buyer_email: string,
 *   buyer_phone?: string,
 *   keywords?: string[],
 *   target_url: string,
 *   content_type?: string,
 *   notes?: string
 * }
 */
router.post('/buy-backlink', async (req, res) => {
  try {
    const {
      site_id,
      buyer_name,
      buyer_email,
      buyer_phone,
      keywords,
      target_url,
      content_type,
      notes
    } = req.body;

    // Validation
    if (!site_id || !buyer_name || !buyer_email || !target_url) {
      return res.status(400).json({
        error: 'Missing required fields: site_id, buyer_name, buyer_email, target_url'
      });
    }

    // Get site details
    const site = await getSiteById(site_id);
    
    if (!site) {
      return res.status(404).json({
        error: 'Site not found'
      });
    }

    // Calculate price (auto-pricing from scoring)
    const priceEstimate = site.backlink_value || calculateBacklinkValue(site, site.spam_score);

    // Create order
    const order = await createOrder({
      site_id,
      site_url: site.url,
      buyer_name,
      buyer_email,
      buyer_phone,
      keywords: keywords || [],
      target_url,
      content_type: content_type || 'guest_post',
      price_estimate: priceEstimate,
      notes
    });

    logger.info(`✅ Created order ${order.invoice_id} for site ${site_id}`);

    // TODO: Integrate Stripe payment
    // const paymentIntent = await stripe.paymentIntents.create({...});

    res.json({
      success: true,
      order: {
        id: order.id,
        invoice_id: order.invoice_id,
        site_url: site.url,
        price_estimate: priceEstimate,
        currency: 'USD',
        status: 'pending'
      },
      // TODO: Add Stripe payment link
      message: 'Order created successfully. Payment integration pending.'
    });

  } catch (err) {
    logger.error('Buy backlink error:', err);
    res.status(500).json({
      error: 'Failed to create order',
      message: err.message
    });
  }
});

/**
 * GET /api/gob/export
 * Export sites as CSV or JSON
 * 
 * Query params:
 * - format: csv|json (default csv)
 * - ...same filters as /list
 */
router.get('/export', async (req, res) => {
  try {
    const format = req.query.format || 'csv';

    const filters = {
      status: req.query.status,
      category: req.query.category,
      hasEmail: req.query.hasEmail === 'true',
      minBacklinkValue: req.query.minBacklinkValue ? parseFloat(req.query.minBacklinkValue) : undefined,
      maxSpamScore: req.query.maxSpamScore ? parseInt(req.query.maxSpamScore) : undefined,
      guestPostOnly: req.query.guestPostOnly === 'true'
    };

    Object.keys(filters).forEach(key => 
      filters[key] === undefined && delete filters[key]
    );

    if (format === 'csv') {
      const { headers, rows } = await exportSitesToCSV(filters);
      
      const csvContent = [
        headers.join(','),
        ...rows.map(row => row.map(cell => 
          typeof cell === 'string' && cell.includes(',') ? `"${cell}"` : cell
        ).join(','))
      ].join('\n');

      res.setHeader('Content-Type', 'text/csv');
      res.setHeader('Content-Disposition', `attachment; filename="gob-export-${Date.now()}.csv"`);
      res.send(csvContent);

    } else if (format === 'json') {
      const result = await listSites(filters, 1, 10000);
      
      res.setHeader('Content-Type', 'application/json');
      res.setHeader('Content-Disposition', `attachment; filename="gob-export-${Date.now()}.json"`);
      res.json({
        exported_at: new Date().toISOString(),
        total: result.total,
        filters,
        data: result.data
      });

    } else {
      res.status(400).json({
        error: 'Invalid format. Use csv or json'
      });
    }

  } catch (err) {
    logger.error('Export error:', err);
    res.status(500).json({
      error: 'Failed to export data',
      message: err.message
    });
  }
});

/**
 * GET /api/gob/health
 * Health check and system stats
 */
router.get('/health', async (req, res) => {
  try {
    const dbHealth = await healthCheck();
    const queueCounts = await queue.getJobCounts();

    res.json({
      success: true,
      status: 'healthy',
      timestamp: new Date().toISOString(),
      database: dbHealth,
      queue: {
        waiting: queueCounts.waiting,
        active: queueCounts.active,
        completed: queueCounts.completed,
        failed: queueCounts.failed
      },
      version: '1.0.0'
    });

  } catch (err) {
    logger.error('Health check error:', err);
    res.status(500).json({
      success: false,
      status: 'unhealthy',
      error: err.message
    });
  }
});

/**
 * GET /api/gob/stats
 * Get scraping statistics
 */
router.get('/stats', async (req, res) => {
  try {
    const { getDbPool } = await import('../db/postgres.js');
    const db = getDbPool();

    const stats = await db.query(`
      SELECT 
        COUNT(*) as total_sites,
        COUNT(*) FILTER (WHERE status = 'scraped') as scraped,
        COUNT(*) FILTER (WHERE status = 'enriched') as enriched,
        COUNT(*) FILTER (WHERE status = 'error') as errors,
        COUNT(*) FILTER (WHERE guest_post_detected = true) as guest_post_sites,
        COUNT(*) FILTER (WHERE jsonb_array_length(emails) > 0) as sites_with_emails,
        AVG(spam_score)::numeric(10,2) as avg_spam_score,
        AVG(backlink_value)::numeric(10,2) as avg_backlink_value
      FROM gob_sites
    `);

    const categoryBreakdown = await db.query(`
      SELECT category, COUNT(*) as count
      FROM gob_sites
      WHERE status = 'enriched'
      GROUP BY category
      ORDER BY count DESC
    `);

    res.json({
      success: true,
      overview: stats.rows[0],
      categories: categoryBreakdown.rows,
      timestamp: new Date().toISOString()
    });

  } catch (err) {
    logger.error('Stats error:', err);
    res.status(500).json({
      error: 'Failed to get stats',
      message: err.message
    });
  }
});

export default router;
