/**
 * Generated by Copilot per prompt: GO-AIBOB (GBOB) â€” GentleOmegaAI
 * 
 * worker.js - Bull queue consumer with Puppeteer scraping
 * 
 * Features:
 * - Headless Chrome with stealth mode
 * - User-agent rotation
 * - Exponential backoff retry
 * - Resource blocking for speed
 * - Memory-efficient page management
 * - Postgres integration for data storage
 * - Automatic scoring and HF enrichment queueing
 * - Comprehensive error handling and logging
 * 
 * Usage: npm run gob:worker
 */

import Queue from 'bull';
import puppeteer from 'puppeteer';
import { promises as fs } from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import pino from 'pino';
import dotenv from 'dotenv';

// Database and scoring
import { getDbPool, insertScrapedSite, updateSiteStatus } from '../db/postgres.js';
import { scoreSite } from '../scoring/score.js';
import { enqueueEnrichment } from '../enrich/queue.js';

// Load environment
dotenv.config({ path: '.env.local' });

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Logger setup
const logger = pino({
  level: process.env.LOG_LEVEL || 'info',
  transport: {
    target: 'pino-pretty',
    options: {
      colorize: true,
      translateTime: 'SYS:standard',
      ignore: 'pid,hostname'
    }
  }
});

// Configuration
const CONFIG = {
  concurrency: parseInt(process.env.MAX_CONCURRENCY || '3'),
  timeout: parseInt(process.env.PAGE_TIMEOUT || '60000'),
  maxRetries: 3,
  headless: process.env.PUPPETEER_HEADLESS !== 'false',
  queueName: process.env.GOB_QUEUE_NAME || 'gob-queue',
  redisUrl: process.env.REDIS_URL,
  maxHtmlLength: parseInt(process.env.MAX_HTML_SNAPSHOT_LENGTH || '200000'),
  maxCostPerRun: parseInt(process.env.MAX_COST_PER_RUN || '100')
};

// User agents for rotation (anti-bot detection)
const USER_AGENTS = [
  'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36',
  'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36',
  'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36',
  'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:123.0) Gecko/20100101 Firefox/123.0',
  'Mozilla/5.0 (Macintosh; Intel Mac OS X 14.3; rv:123.0) Gecko/20100101 Firefox/123.0'
];

// Initialize Bull queue
const queue = new Queue(CONFIG.queueName, CONFIG.redisUrl, {
  defaultJobOptions: {
    attempts: CONFIG.maxRetries,
    backoff: {
      type: 'exponential',
      delay: 5000 // Start with 5s, doubles each retry
    },
    removeOnComplete: 100, // Keep last 100 completed jobs
    removeOnFail: 500 // Keep last 500 failed jobs for debugging
  }
});

// Track active browser instance
let browser = null;
let browserPagePool = [];
const MAX_BROWSER_PAGES = CONFIG.concurrency;

/**
 * Initialize browser with optimized settings
 */
async function initBrowser() {
  if (browser) return browser;

  logger.info('ðŸš€ Initializing Puppeteer browser...');

  browser = await puppeteer.launch({
    headless: CONFIG.headless ? 'new' : false,
    args: [
      '--no-sandbox',
      '--disable-setuid-sandbox',
      '--disable-dev-shm-usage',
      '--disable-accelerated-2d-canvas',
      '--no-first-run',
      '--no-zygote',
      '--disable-gpu',
      '--disable-background-timer-throttling',
      '--disable-backgrounding-occluded-windows',
      '--disable-renderer-backgrounding',
      '--disable-features=site-per-process',
      '--window-size=1920,1080'
    ],
    defaultViewport: {
      width: 1920,
      height: 1080
    }
  });

  logger.info('âœ… Browser initialized successfully');

  // Handle browser crashes
  browser.on('disconnected', () => {
    logger.error('âŒ Browser disconnected unexpectedly');
    browser = null;
    browserPagePool = [];
  });

  return browser;
}

/**
 * Get or create a page from pool
 */
async function getPage() {
  const browserInstance = await initBrowser();
  
  // Reuse existing page if available
  if (browserPagePool.length > 0) {
    return browserPagePool.pop();
  }

  // Create new page
  const page = await browserInstance.newPage();

  // Set random user agent
  const userAgent = USER_AGENTS[Math.floor(Math.random() * USER_AGENTS.length)];
  await page.setUserAgent(userAgent);

  // Block unnecessary resources for speed
  await page.setRequestInterception(true);
  page.on('request', (request) => {
    const resourceType = request.resourceType();
    const blockedTypes = ['image', 'stylesheet', 'font', 'media'];
    
    if (blockedTypes.includes(resourceType)) {
      request.abort();
    } else {
      request.continue();
    }
  });

  // Add stealth techniques
  await page.evaluateOnNewDocument(() => {
    // Override navigator properties
    Object.defineProperty(navigator, 'webdriver', {
      get: () => false
    });

    // Override chrome property
    window.chrome = {
      runtime: {}
    };

    // Override permissions
    const originalQuery = window.navigator.permissions.query;
    window.navigator.permissions.query = (parameters) => (
      parameters.name === 'notifications'
        ? Promise.resolve({ state: Notification.permission })
        : originalQuery(parameters)
    );
  });

  return page;
}

/**
 * Return page to pool or close if pool is full
 */
async function releasePage(page) {
  if (browserPagePool.length < MAX_BROWSER_PAGES) {
    try {
      // Clear page state
      await page.goto('about:blank');
      await page.evaluate(() => localStorage.clear());
      browserPagePool.push(page);
    } catch (err) {
      logger.warn('Failed to reset page, closing:', err.message);
      await page.close().catch(() => {});
    }
  } else {
    await page.close().catch(() => {});
  }
}

/**
 * Load pageFunction from file
 */
async function loadPageFunction() {
  const pageFunctionPath = path.join(__dirname, 'pageFunction.js');
  const pageFunctionCode = await fs.readFile(pageFunctionPath, 'utf-8');
  
  // Extract the function body (remove module.exports)
  const functionBody = pageFunctionCode
    .replace(/module\.exports\s*=\s*pageFunction;?/g, '')
    .replace(/if\s*\(typeof\s+module.*?\}/gs, '')
    .trim();

  return functionBody;
}

/**
 * Scrape a single URL
 */
async function scrapeUrl(url, jobId) {
  const startTime = Date.now();
  let page = null;

  try {
    logger.info(`ðŸ“„ [Job ${jobId}] Starting scrape: ${url}`);

    // Get page from pool
    page = await getPage();

    // Navigate to URL
    const response = await page.goto(url, {
      waitUntil: 'networkidle2',
      timeout: CONFIG.timeout
    });

    // Check response status
    const status = response.status();
    if (status >= 400) {
      throw new Error(`HTTP ${status}: ${response.statusText()}`);
    }

    // Load and execute pageFunction
    const pageFunctionCode = await loadPageFunction();
    const extractedData = await page.evaluate(`
      (${pageFunctionCode})()
    `);

    // Validate extraction
    if (!extractedData || typeof extractedData !== 'object') {
      throw new Error('pageFunction returned invalid data');
    }

    // Truncate HTML if needed
    if (extractedData.htmlSnapshot && extractedData.htmlSnapshot.length > CONFIG.maxHtmlLength) {
      extractedData.htmlSnapshot = extractedData.htmlSnapshot.substring(0, CONFIG.maxHtmlLength);
      extractedData.htmlSnapshot += '\n<!-- TRUNCATED -->';
    }

    // Calculate scores
    const scores = scoreSite(extractedData);

    // Merge data
    const siteData = {
      ...extractedData,
      ...scores,
      status: 'scraped',
      scraped_at: new Date()
    };

    const scrapeDuration = Date.now() - startTime;
    logger.info(`âœ… [Job ${jobId}] Scraped successfully in ${scrapeDuration}ms`);

    return {
      success: true,
      data: siteData,
      duration: scrapeDuration
    };

  } catch (err) {
    const duration = Date.now() - startTime;
    
    // Categorize error
    let errorType = 'unknown';
    let status = 'error';

    if (err.message.includes('timeout')) {
      errorType = 'timeout';
      status = 'timeout';
    } else if (err.message.includes('HTTP 403') || err.message.includes('HTTP 429')) {
      errorType = 'blocked';
      status = 'blocked';
    } else if (err.message.includes('net::ERR')) {
      errorType = 'network';
      status = 'error';
    }

    logger.error(`âŒ [Job ${jobId}] Scrape failed (${errorType}): ${err.message}`);

    return {
      success: false,
      error: err.message,
      errorType,
      status,
      duration
    };

  } finally {
    if (page) {
      await releasePage(page);
    }
  }
}

/**
 * Process a job from the queue
 */
async function processJob(job) {
  const { url, metadata = {} } = job.data;
  const jobId = job.id;

  logger.info(`ðŸ”„ [Job ${jobId}] Processing: ${url}`);

  // Update status to scraping
  try {
    await updateSiteStatus(url, 'scraping');
  } catch (err) {
    logger.warn(`Failed to update status for ${url}:`, err.message);
  }

  // Attempt scraping
  const result = await scrapeUrl(url, jobId);

  if (result.success) {
    // Save to database
    try {
      const siteId = await insertScrapedSite(result.data);
      logger.info(`ðŸ’¾ [Job ${jobId}] Saved to database with ID: ${siteId}`);

      // Enqueue HuggingFace enrichment
      if (process.env.HuggingFace_API_Key) {
        try {
          await enqueueEnrichment(siteId, result.data);
          logger.info(`ðŸ¤– [Job ${jobId}] Queued for HF enrichment`);
        } catch (err) {
          logger.warn(`Failed to enqueue enrichment for ${url}:`, err.message);
        }
      }

      // Update job progress
      await job.progress(100);

      return {
        siteId,
        url,
        status: 'scraped',
        ...result
      };

    } catch (err) {
      logger.error(`âŒ [Job ${jobId}] Database save failed:`, err);
      await updateSiteStatus(url, 'error', err.message);
      throw err;
    }

  } else {
    // Update status based on error type
    await updateSiteStatus(url, result.status, result.error);
    
    // Retry logic (Bull handles this automatically)
    if (result.errorType === 'blocked' || result.errorType === 'timeout') {
      throw new Error(`Retryable error: ${result.error}`);
    } else {
      // Don't retry network errors
      logger.warn(`âŒ [Job ${jobId}] Non-retryable error, marking as failed`);
      throw new Error(result.error);
    }
  }
}

/**
 * Start the worker
 */
async function startWorker() {
  logger.info('ðŸŽ¬ GO-AIBOB Worker starting...');
  logger.info(`ðŸ“Š Configuration:`, {
    concurrency: CONFIG.concurrency,
    timeout: CONFIG.timeout,
    headless: CONFIG.headless,
    queueName: CONFIG.queueName
  });

  // Initialize database connection
  try {
    await getDbPool();
    logger.info('âœ… Database connection established');
  } catch (err) {
    logger.error('âŒ Database connection failed:', err);
    process.exit(1);
  }

  // Initialize browser
  try {
    await initBrowser();
  } catch (err) {
    logger.error('âŒ Browser initialization failed:', err);
    process.exit(1);
  }

  // Setup queue event handlers
  queue.on('completed', (job, result) => {
    logger.info(`âœ… Job ${job.id} completed:`, result);
  });

  queue.on('failed', (job, err) => {
    logger.error(`âŒ Job ${job.id} failed:`, err.message);
  });

  queue.on('stalled', (job) => {
    logger.warn(`âš ï¸  Job ${job.id} stalled`);
  });

  // Process jobs
  queue.process(CONFIG.concurrency, async (job) => {
    return await processJob(job);
  });

  logger.info(`âœ… Worker started with concurrency: ${CONFIG.concurrency}`);
  logger.info('â³ Waiting for jobs...');

  // Graceful shutdown
  process.on('SIGTERM', async () => {
    logger.info('ðŸ›‘ SIGTERM received, shutting down gracefully...');
    await queue.close();
    if (browser) await browser.close();
    process.exit(0);
  });

  process.on('SIGINT', async () => {
    logger.info('ðŸ›‘ SIGINT received, shutting down gracefully...');
    await queue.close();
    if (browser) await browser.close();
    process.exit(0);
  });
}

// Start if run directly
if (import.meta.url === `file://${process.argv[1]}`) {
  startWorker().catch((err) => {
    logger.error('Fatal error:', err);
    process.exit(1);
  });
}

export { queue, scrapeUrl, startWorker };
