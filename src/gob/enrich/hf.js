/**
 * Generated by Copilot per prompt: GO-AIBOB (GBOB) ‚Äî GentleOmegaAI
 * 
 * hf.js - HuggingFace Inference API wrapper with intelligent enrichment
 * 
 * Features:
 * - Multiple model support (language, classification, summarization, sentiment)
 * - Key rotation for rate limit handling
 * - Exponential backoff retry
 * - Response caching
 * - Cost tracking
 * 
 * Models Used (FREE tier optimized):
 * 1. Language Detection: papluca/xlm-roberta-base-language-detection
 * 2. Classification: facebook/bart-large-mnli (zero-shot)
 * 3. Summarization: facebook/bart-large-cnn
 * 4. Sentiment: cardiffnlp/twitter-roberta-base-sentiment-latest
 */

import axios from 'axios';
import pino from 'pino';
import pLimit from 'p-limit';
import dotenv from 'dotenv';

dotenv.config({ path: '.env.local' });

const logger = pino({
  level: process.env.LOG_LEVEL || 'info',
  transport: {
    target: 'pino-pretty',
    options: { colorize: true }
  }
});

// HuggingFace API configuration
const HF_API_BASE = 'https://api-inference.huggingface.co/models';
const API_KEYS = [
  process.env.HuggingFace_API_Key,
  process.env.HF_API_KEY_2,
  process.env.HF_API_KEY_3,
  process.env.HF_API_KEY_4
].filter(Boolean);

if (API_KEYS.length === 0) {
  logger.warn('‚ö†Ô∏è  No HuggingFace API keys found in environment');
}

// Rate limiting
const requestsPerMinute = parseInt(process.env.HF_REQUESTS_PER_MINUTE || '10');
const limiter = pLimit(requestsPerMinute);

// Response cache (in-memory, simple)
const cache = new Map();
const CACHE_TTL = parseInt(process.env.HF_CACHE_TTL || '3600') * 1000; // 1 hour default

// Track API usage
let apiCallCount = 0;
let currentKeyIndex = 0;

/**
 * Get next API key (rotation)
 */
function getApiKey() {
  if (API_KEYS.length === 0) {
    throw new Error('No HuggingFace API keys configured');
  }
  
  const key = API_KEYS[currentKeyIndex];
  currentKeyIndex = (currentKeyIndex + 1) % API_KEYS.length;
  return key;
}

/**
 * Make API call with retry and backoff
 */
async function callHuggingFace(modelId, payload, options = {}) {
  const maxRetries = options.maxRetries || 3;
  const baseDelay = options.baseDelay || 2000;
  
  const cacheKey = `${modelId}:${JSON.stringify(payload)}`;
  
  // Check cache
  if (cache.has(cacheKey)) {
    const cached = cache.get(cacheKey);
    if (Date.now() - cached.timestamp < CACHE_TTL) {
      logger.debug(`üì¶ Cache hit for ${modelId}`);
      return cached.data;
    } else {
      cache.delete(cacheKey);
    }
  }

  let lastError;
  
  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      const apiKey = getApiKey();
      
      logger.debug(`ü§ñ Calling HF model: ${modelId} (attempt ${attempt + 1}/${maxRetries})`);
      
      const response = await axios.post(
        `${HF_API_BASE}/${modelId}`,
        payload,
        {
          headers: {
            'Authorization': `Bearer ${apiKey}`,
            'Content-Type': 'application/json'
          },
          timeout: options.timeout || 30000
        }
      );

      apiCallCount++;
      
      // Cache successful response
      cache.set(cacheKey, {
        data: response.data,
        timestamp: Date.now()
      });

      return response.data;

    } catch (error) {
      lastError = error;
      
      // Handle rate limiting
      if (error.response?.status === 429) {
        const retryAfter = parseInt(error.response.headers['retry-after'] || '60');
        logger.warn(`‚è≥ Rate limited, waiting ${retryAfter}s`);
        await sleep(retryAfter * 1000);
        continue;
      }

      // Handle model loading (503)
      if (error.response?.status === 503) {
        const estimatedTime = error.response.data?.estimated_time || 20;
        logger.warn(`‚è≥ Model loading, waiting ${estimatedTime}s`);
        await sleep(estimatedTime * 1000);
        continue;
      }

      // Exponential backoff for other errors
      if (attempt < maxRetries - 1) {
        const delay = baseDelay * Math.pow(2, attempt);
        logger.warn(`‚ö†Ô∏è  Attempt ${attempt + 1} failed, retrying in ${delay}ms`);
        await sleep(delay);
      }
    }
  }

  logger.error(`‚ùå HF API call failed after ${maxRetries} attempts:`, lastError?.message);
  throw lastError;
}

/**
 * Sleep utility
 */
function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

/**
 * Detect language
 */
export async function detectLanguage(text) {
  if (!text || text.length < 20) {
    return { language: 'unknown', confidence: 0 };
  }

  try {
    const result = await limiter(() =>
      callHuggingFace('papluca/xlm-roberta-base-language-detection', {
        inputs: text.substring(0, 500) // Limit input length
      })
    );

    if (result && result[0] && result[0].length > 0) {
      return {
        language: result[0][0].label,
        confidence: result[0][0].score
      };
    }

    return { language: 'unknown', confidence: 0 };
  } catch (err) {
    logger.error('Language detection failed:', err.message);
    return { language: 'unknown', confidence: 0, error: err.message };
  }
}

/**
 * Classify content category (zero-shot)
 */
export async function classifyCategory(text, title = '') {
  const fullText = `${title}\n\n${text}`.substring(0, 1000);

  const candidateLabels = [
    'SaaS',
    'Health',
    'Finance',
    'Marketing',
    'Travel',
    'Education',
    'Technology',
    'Other'
  ];

  try {
    const result = await limiter(() =>
      callHuggingFace('facebook/bart-large-mnli', {
        inputs: fullText,
        parameters: {
          candidate_labels: candidateLabels
        }
      })
    );

    if (result && result.labels && result.scores) {
      return {
        category: result.labels[0],
        confidence: result.scores[0],
        allScores: result.labels.map((label, i) => ({
          label,
          score: result.scores[i]
        }))
      };
    }

    return { category: 'Other', confidence: 0 };
  } catch (err) {
    logger.error('Category classification failed:', err.message);
    return { category: 'Other', confidence: 0, error: err.message };
  }
}

/**
 * Generate summary
 */
export async function generateSummary(text) {
  if (!text || text.length < 100) {
    return { summary: text, error: 'Text too short' };
  }

  try {
    const result = await limiter(() =>
      callHuggingFace('facebook/bart-large-cnn', {
        inputs: text.substring(0, 5000), // Limit to 5k chars
        parameters: {
          max_length: 150,
          min_length: 30,
          do_sample: false
        }
      })
    );

    if (result && result[0] && result[0].summary_text) {
      return {
        summary: result[0].summary_text,
        confidence: 1.0
      };
    }

    return { summary: text.substring(0, 200) + '...', confidence: 0 };
  } catch (err) {
    logger.error('Summarization failed:', err.message);
    return { summary: text.substring(0, 200) + '...', confidence: 0, error: err.message };
  }
}

/**
 * Analyze sentiment
 */
export async function analyzeSentiment(text) {
  if (!text || text.length < 20) {
    return { sentiment: 'neutral', confidence: 0 };
  }

  try {
    const result = await limiter(() =>
      callHuggingFace('cardiffnlp/twitter-roberta-base-sentiment-latest', {
        inputs: text.substring(0, 500)
      })
    );

    if (result && result[0] && result[0].length > 0) {
      return {
        sentiment: result[0][0].label,
        confidence: result[0][0].score,
        allScores: result[0]
      };
    }

    return { sentiment: 'neutral', confidence: 0 };
  } catch (err) {
    logger.error('Sentiment analysis failed:', err.message);
    return { sentiment: 'neutral', confidence: 0, error: err.message };
  }
}

/**
 * Detect guest post indicators (advanced)
 */
export function detectGuestPostOpportunity(text, guestPostKeywords = []) {
  if (!text) return { detected: false, confidence: 0, keywords: [] };

  const textLower = text.toLowerCase();
  
  // Weighted keywords
  const strongIndicators = [
    'write for us',
    'contributor guidelines',
    'become a contributor',
    'submit article',
    'guest author'
  ];

  const mediumIndicators = [
    'guest post',
    'submit guest',
    'contribute',
    'guest blogging',
    'write an article'
  ];

  let score = 0;
  const foundKeywords = [];

  strongIndicators.forEach(keyword => {
    if (textLower.includes(keyword)) {
      score += 3;
      foundKeywords.push(keyword);
    }
  });

  mediumIndicators.forEach(keyword => {
    if (textLower.includes(keyword)) {
      score += 1;
      foundKeywords.push(keyword);
    }
  });

  // Additional heuristics
  if (textLower.includes('guidelines') && textLower.includes('submit')) score += 1;
  if (textLower.includes('contact us') && textLower.includes('write')) score += 1;

  const detected = score >= 2;
  const confidence = Math.min(score / 5, 1.0);

  return {
    detected,
    confidence,
    keywords: [...new Set(foundKeywords)],
    score
  };
}

/**
 * Comprehensive enrichment (all models)
 */
export async function enrichSite(siteData) {
  const startTime = Date.now();
  
  logger.info(`ü§ñ Starting enrichment for: ${siteData.url}`);

  const text = [
    siteData.title,
    siteData.metaDesc,
    siteData.firstParagraph
  ].filter(Boolean).join('\n\n');

  if (!text || text.length < 50) {
    logger.warn('‚ö†Ô∏è  Insufficient text for enrichment');
    return {
      category: 'Other',
      language: 'unknown',
      summary: null,
      sentiment: 'neutral',
      guest_post_detected: false,
      enrichment_quality: 'low',
      enriched_at: new Date().toISOString()
    };
  }

  try {
    // Run all analyses in parallel
    const [
      languageResult,
      categoryResult,
      summaryResult,
      sentimentResult
    ] = await Promise.allSettled([
      detectLanguage(text),
      classifyCategory(text, siteData.title),
      generateSummary(text),
      analyzeSentiment(text)
    ]);

    // Guest post detection (local, no API call)
    const guestPostResult = detectGuestPostOpportunity(
      siteData.htmlSnapshot || text,
      siteData.guestPostKeywords
    );

    const enrichment = {
      category: categoryResult.status === 'fulfilled' ? categoryResult.value.category : 'Other',
      category_confidence: categoryResult.status === 'fulfilled' ? categoryResult.value.confidence : 0,
      
      language: languageResult.status === 'fulfilled' ? languageResult.value.language : 'unknown',
      language_confidence: languageResult.status === 'fulfilled' ? languageResult.value.confidence : 0,
      
      summary: summaryResult.status === 'fulfilled' ? summaryResult.value.summary : null,
      summary_confidence: summaryResult.status === 'fulfilled' ? summaryResult.value.confidence : 0,
      
      sentiment: sentimentResult.status === 'fulfilled' ? sentimentResult.value.sentiment : 'neutral',
      sentiment_confidence: sentimentResult.status === 'fulfilled' ? sentimentResult.value.confidence : 0,
      
      guest_post_detected: guestPostResult.detected,
      guest_post_confidence: guestPostResult.confidence,
      guest_post_keywords: guestPostResult.keywords,
      
      enrichment_quality: calculateEnrichmentQuality({
        categoryResult,
        languageResult,
        summaryResult,
        sentimentResult
      }),
      
      api_calls: 4, // Number of HF API calls made
      processing_time_ms: Date.now() - startTime,
      enriched_at: new Date().toISOString()
    };

    logger.info(`‚úÖ Enrichment completed in ${enrichment.processing_time_ms}ms`);
    
    return enrichment;

  } catch (err) {
    logger.error('‚ùå Enrichment failed:', err);
    return {
      category: 'Other',
      language: 'unknown',
      summary: null,
      sentiment: 'neutral',
      guest_post_detected: false,
      enrichment_quality: 'failed',
      error: err.message,
      enriched_at: new Date().toISOString()
    };
  }
}

/**
 * Calculate enrichment quality score
 */
function calculateEnrichmentQuality(results) {
  const successCount = Object.values(results).filter(
    r => r.status === 'fulfilled'
  ).length;
  
  const total = Object.keys(results).length;
  const successRate = successCount / total;
  
  if (successRate >= 0.75) return 'high';
  if (successRate >= 0.5) return 'medium';
  return 'low';
}

/**
 * Get API usage stats
 */
export function getApiStats() {
  return {
    totalCalls: apiCallCount,
    cacheSize: cache.size,
    keysAvailable: API_KEYS.length,
    currentKeyIndex
  };
}

/**
 * Clear cache (for testing/maintenance)
 */
export function clearCache() {
  cache.clear();
  logger.info('‚úÖ HF cache cleared');
}

export default {
  detectLanguage,
  classifyCategory,
  generateSummary,
  analyzeSentiment,
  detectGuestPostOpportunity,
  enrichSite,
  getApiStats,
  clearCache
};
